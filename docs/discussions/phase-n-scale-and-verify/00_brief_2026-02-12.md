# ğŸ¼ Äá» bÃ i Tháº£o luáº­n â€” Phase N: Scale & Verify

> **NgÃ y:** 2026-02-12
> **Participants:** GPT-Visionary-Agent (Visionary), Gemini-Pragmatist-Agent (Pragmatist)
> **Äiá»u phá»‘i:** Orchestra Agent

---

## Bá»‘i cáº£nh dá»± Ã¡n

AegisOS lÃ  bare-metal AArch64 microkernel nháº¯m vÃ o há»‡ thá»‘ng safety-critical (rocket, y táº¿, xe tá»± lÃ¡i). Sau 13 phases (Aâ†’M):
- **96.65% code coverage**, 219 host tests, 28 QEMU boot checkpoints
- `KernelCell<T>` pattern Ä‘Ã£ encapsulate 4 scalar globals (`TICK_COUNT`, `CURRENT`, `EPOCH_TICKS`, `TICK_INTERVAL`)
- CÃ²n **4 `static mut` struct-array globals**: `TCBS`, `ENDPOINTS`, `GRANTS`, `IRQ_BINDINGS`
- Kernel chá»‰ há»— trá»£ **3 tasks cá»‘ Ä‘á»‹nh** â€” hardcoded á»Ÿ 15+ locations (sched, mmu, linker, main)
- ChÆ°a cÃ³ **formal verification** â€” chá»‰ cÃ³ runtime tests

### Tráº¡ng thÃ¡i hiá»‡n táº¡i chi tiáº¿t

| Aspect | Current State |
|--------|--------------|
| `NUM_TASKS` | 3 (hardcoded in `sched.rs`) |
| `PAGE_TABLE_COUNT` | 16 (4Ã—3 tasks + 4 kernel) |
| `TCBS` | `pub static mut [Tcb; 3]` â€” dÃ¹ng `EMPTY_TCB` const, **khÃ´ng cÃ³ `Tcb::new()`** |
| `ENDPOINTS` | `pub static mut [Endpoint; 4]` |
| `GRANTS` | `pub static mut [Grant; 2]` |
| `IRQ_BINDINGS` | `pub static mut [IrqBinding; 8]` |
| MMU page tables | 13 named constants (`PT_L1_TASK0`, `PT_L2_RAM_TASK1`...) â€” khÃ´ng scale |
| `init_tasks()` | 3 positional args + 3 copy-paste blocks cho caps/priority/ttbr0 |
| Linker sections | `.task_stacks 3Ã—4096`, `.user_stacks 3Ã—4096`, `.page_tables 16Ã—4096` |
| CI | 2 jobs: `host-tests` + `qemu-boot` (no formal verification) |
| Cargo.toml | Zero dependencies, edition 2021, `#![no_std]` â€” Kani-compatible |

### Phase N Plan tÃ³m táº¯t

| Sub-phase | Má»¥c tiÃªu | Effort Æ°á»›c lÆ°á»£ng |
|-----------|----------|-----------------|
| **N1** | Scale `NUM_TASKS` 3â†’8: constants, linker, MMU computed indexing, `TaskConfig` table | ~12-14h |
| **N2** | `KernelCell` cho 4 struct arrays (GRANTS â†’ IRQ â†’ ENDPOINTS â†’ TCBS) | ~16-21h |
| **N3** | Kani formal verification pilot: `cap.rs` + `elf.rs` + `cell.rs` (6 proofs) | ~9-13h |

### PhÃ¡t hiá»‡n quan trá»ng tá»« nghiÃªn cá»©u

1. **`EMPTY_TCB` lÃ  `const`** â†’ `KernelCell<[Tcb; 8]>` sáº½ compile. Risk #2 trong plan Ä‘Ã£ mitigated.
2. **`cap_for_syscall()` tráº£ `u64` bitmask** (khÃ´ng pháº£i bit index) â†’ Kani property cáº§n verify "return is subset of `0x3FFFF`", khÃ´ng pháº£i "â‰¤ 17".
3. **`has_capability()` khÃ´ng tá»“n táº¡i** trong `cap.rs` â€” chá»‰ cÃ³ `cap_check()`. Plan cáº§n chá»‰nh.
4. **Kani trÃªn `parse_elf64` vá»›i 4096 bytes** cÃ³ thá»ƒ quÃ¡ cháº­m â€” CBMC pháº£i explore má»i byte combination. Suggest 64-128 bytes.
5. **MMU refactor lÃ  rá»§i ro cao nháº¥t** â€” 594 dÃ²ng vá»›i L1â†’L2â†’L3 chaining phá»©c táº¡p, 13 named constants cáº§n thay.
6. **Idle task fallback** hardcode `task_id == 2` â†’ cáº§n Ä‘á»•i sang `NUM_TASKS - 1` (= 7).
7. **ELF load region** hardcoded `0x4010_0000` chá»‰ 3Ã—4096 = 12 KiB â€” chÆ°a address multi-task ELF loading.
8. **Kani `elf.rs` harness dÃ¹ng `Vec<u8>`** â€” cáº§n `alloc`, nhÆ°ng Kani cháº¡y trÃªn host nÃªn OK (std available).

---

## CÃ¢u há»i tháº£o luáº­n

### Q1: Chiáº¿n lÆ°á»£c scale NUM_TASKS â€” Jump to 8 hay Incremental (3â†’4â†’8)?

Phase N plan Ä‘á» xuáº¥t nháº£y tháº³ng tá»« 3â†’8. NhÆ°ng MMU refactor rá»§i ro cao (594 dÃ²ng, 13 constants). CÃ³ nÃªn:
- **(A)** Nháº£y tháº³ng 3â†’8 (fast, 1 refactor)
- **(B)** Incremental: 3â†’4 (validate computed indexing) â†’ 4â†’8 (scale confidence)
- **(C)** Parameterize nhÆ°ng giá»¯ `NUM_TASKS=3` trÆ°á»›c, chá»‰ chuyá»ƒn sang 8 sau khi tests confirm

CÃ¢n nháº¯c: effort, risk, schedule impact, validation confidence.

### Q2: KernelCell wrapping order â€” Plan Ä‘á» xuáº¥t GRANTSâ†’IRQâ†’ENDPOINTSâ†’TCBS. CÃ³ nÃªn Ä‘áº£o?

Plan chá»n thá»© tá»± tá»« Ä‘Æ¡n giáº£nâ†’phá»©c táº¡p. NhÆ°ng:
- TCBS lÃ  **critical nháº¥t** (scheduler, context switch) â€” nÃªn wrap sá»›m Ä‘á»ƒ validate pattern?
- Hay wrap TCBS cuá»‘i Ä‘á»ƒ **giáº£m risk** khi Ä‘Ã£ cÃ³ kinh nghiá»‡m tá»« 3 globals Ä‘Æ¡n giáº£n hÆ¡n?
- ENDPOINTS phá»©c táº¡p hÆ¡n GRANTS nhÆ°ng Ã­t refs hÆ¡n TCBS â€” middle ground?

Cáº§n phÃ¢n tÃ­ch: risk-first vs experience-first, rollback cost, test migration effort.

### Q3: Kani pilot scope â€” 6 proofs Ä‘á»§ hay nÃªn má»Ÿ rá»™ng/thu háº¹p?

Plan Ä‘á» xuáº¥t 6 proofs (4 `cap.rs` + 1 `elf.rs` + 1 `cell.rs`). NhÆ°ng:
- `cap.rs` cÃ³ 4 proofs â€” quÃ¡ nhiá»u cho 1 module nhá»?
- `elf.rs` chá»‰ 1 proof nhÆ°ng input 4096 bytes â†’ Kani timeout risk cao
- CÃ³ nÃªn thÃªm proof cho `sched.rs` (scheduler invariants) hoáº·c `grant.rs` (owner/peer)?
- DO-333 yÃªu cáº§u gÃ¬ cá»¥ thá»ƒ cho "pilot" level formal verification?

Cáº§n phÃ¢n tÃ­ch: ROI per proof, Kani performance limits, safety standard requirements.

### Q4: N1-N2-N3 sequencing â€” Parallel hay Sequential?

Plan nÃ³i N3 (Kani) cháº¡y song song vá»›i N1-N2. NhÆ°ng:
- Náº¿u N1 thay Ä‘á»•i `NUM_TASKS` â†’ Kani proofs cho `cap.rs` (dÃ¹ng `NUM_TASKS`) cáº§n update
- Náº¿u N2 wrap `TCBS` â†’ Kani cÃ³ thá»ƒ verify `KernelCell` patterns
- N3a (Kani setup) thá»±c sá»± independent, nhÆ°ng N3b-N3d phá»¥ thuá»™c N1 constants

Sequencing tá»‘i Æ°u lÃ  gÃ¬? Full parallel? N1â†’N3â†’N2? N1â†’N2â†’N3?

### Q5: TaskConfig table design â€” Static const array hay runtime init?

Plan Ä‘á» xuáº¥t `const TASK_CONFIGS: [TaskConfig; NUM_TASKS]`. NhÆ°ng:
- Entry points lÃ  function pointers â€” cÃ³ thá»ƒ dÃ¹ng trong `const`?
- ELF-loaded tasks (user/hello) cÃ³ entry tá»« ELF parsing â†’ runtime value, khÃ´ng const
- CÃ³ nÃªn chia: `const BASE_CONFIGS` (caps, priority, budget) + runtime `entry` assignment?
- Hay giá»¯ toÃ n bá»™ runtime init nhÆ°ng trong loop thay vÃ¬ copy-paste?

Cáº§n phÃ¢n tÃ­ch: const-correctness, flexibility, safety implications.

---

## RÃ ng buá»™c Ä‘Ã£ biáº¿t

1. **No heap** â€” má»i allocation pháº£i static
2. **No FP/SIMD** â€” CPACR_EL1.FPEN=0
3. **TrapFrame = 288 bytes** â€” ABI-locked, khÃ´ng Ä‘á»•i
4. **W^X enforced** â€” MMU refactor pháº£i giá»¯ nguyÃªn
5. **219 tests + 28 checkpoints** â€” regression gate, má»—i step pháº£i pass
6. **Syscall ABI khÃ´ng Ä‘á»•i** â€” x7=nr, x6=ep, x0-x3=payload
7. **RAM 128 MiB** â€” delta 122 KiB cho 8 tasks = 0.09%, khÃ´ng Ä‘Ã¡ng ká»ƒ
8. **Kani cháº¡y trÃªn host (x86_64)** â€” khÃ´ng verify `#[cfg(target_arch = "aarch64")]` code
9. **Single-core** â€” Cortex-A53 uniprocessor, no SMP concerns hiá»‡n táº¡i

## TiÃªu chÃ­ Ä‘Ã¡nh giÃ¡ thÃ nh cÃ´ng

1. **Functional**: 8 tasks boot trÃªn QEMU, tasks 0-2 giá»¯ behavior cÅ©, tasks 3-7 idle
2. **Safety**: 0 `static mut` globals cÃ²n láº¡i, táº¥t cáº£ wrapped trong `KernelCell<T>`
3. **Verification**: â‰¥6 Kani proofs pass, CI green
4. **Regression**: Coverage â‰¥ 95%, 219+ tests pass, 30 QEMU checkpoints pass
5. **Maintainability**: ThÃªm task má»›i chá»‰ cáº§n sá»­a `TASK_CONFIGS` array + linker constant â€” khÃ´ng copy-paste
6. **Standards alignment**: DO-333 pilot evidence, IEC 62304 unit verification, ISO 26262 ASIL decomposition ready
