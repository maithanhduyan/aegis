# ğŸ¼ Äá» bÃ i Tháº£o luáº­n â€” Phase O: Multi-ELF & User Ecosystem

> **NgÃ y:** 2026-02-12
> **Participants:** GPT-Visionary-Agent (Visionary), Gemini-Pragmatist-Agent (Pragmatist)
> **Äiá»u phá»‘i:** Orchestra Agent

---

## Bá»‘i cáº£nh dá»± Ã¡n

AegisOS lÃ  bare-metal AArch64 microkernel nháº¯m vÃ o há»‡ thá»‘ng safety-critical (rocket, y táº¿, xe tá»± lÃ¡i). Sau 14 phases (Aâ†’N):
- **99.02% code coverage**, 231 host tests, 30 QEMU boot checkpoints
- **8 tasks** (NUM_TASKS=8), nhÆ°ng chá»‰ **3 active** (task 0: uart_driver, task 1: client, task 7: idle/ELF demo)
- **5 task slots Inactive** (tasks 2â€“6) â€” chÆ°a dÃ¹ng
- **0 `static mut`** â€” 100% globals wrapped trong `KernelCell<T>`
- **6 Kani proofs** â€” cap_check, cap_for_syscall, pt_index (bounds + aliasing), schedule idle guarantee, restart state machine
- **13 syscalls** (#0â€“#12), 18 capability bits (0â€“17), 46 bits trá»‘ng
- **1 user ELF binary** (`user/hello`) â€” load vÃ o 12 KiB region táº¡i `0x4010_0000`, embedded via `include_bytes!`

### Tráº¡ng thÃ¡i hiá»‡n táº¡i chi tiáº¿t

| Aspect | Current State |
|--------|--------------|
| `NUM_TASKS` | 8 (tasks 0,1 active + task 7 ELF demo, tasks 2â€“6 Inactive) |
| `IDLE_TASK_ID` | 7 (= NUM_TASKS - 1) |
| ELF load region | 12 KiB (3 pages) táº¡i `0x4010_0000` â€” chá»‰ 1 binary |
| `MAX_ENDPOINTS` | 4, `MAX_WAITERS` = 4 per endpoint |
| `MAX_GRANTS` | 2 |
| `MAX_IRQ_BINDINGS` | 8 |
| `MAX_SEGMENTS` (ELF) | 4 |
| User binary | `user/hello/` â€” 62 dÃ²ng, duplicate syscall wrappers, links at `0x4010_0000` |
| Syscall ABI | x7=nr, x6=ep_id, x0â€“x3=payload. Syscalls 0â€“12 defined |
| Capability bits | 0â€“17 used, 18â€“63 free |
| Kani | 6 proofs: cap.rs (2), mmu.rs (2), sched.rs (2). ChÆ°a verify IPC |
| TaskState | Inactive, Ready, Running, Blocked, Faulted (5 variants) |
| Task exit | KhÃ´ng cÃ³ SYS_EXIT â€” task chá»‰ fault hoáº·c loop forever |

### Phase O Plan tÃ³m táº¯t

| Sub-phase | Má»¥c tiÃªu | Effort Æ°á»›c lÆ°á»£ng |
|-----------|----------|-----------------|
| **O1** | Multi-ELF Loading: má»Ÿ rá»™ng .elf_load 12â†’96 KiB, `load_elf_to_task()`, táº¡o user/sensor + user/logger | ~26h |
| **O2** | `libsyscall`: user syscall library dÃ¹ng chung | ~6h |
| **O3** | SYS_EXIT (#13) + TaskState::Exited + cleanup IPC/grant/IRQ | ~14h |
| **O4** | Kani IPC proofs: SenderQueue overflow, message integrity, cleanup completeness | ~12h |

### PhÃ¡t hiá»‡n quan trá»ng tá»« nghiÃªn cá»©u

1. **5/8 task slots lÃ£ng phÃ­** â€” Phase N scale 3â†’8 nhÆ°ng chá»‰ 3 tasks tháº­t sá»± cháº¡y. Tasks 2â€“6 = `Inactive`.
2. **User binary duplicate code** â€” `user/hello/src/main.rs` chá»©a 18+ dÃ²ng syscall asm copy-paste tá»« `main.rs`. Má»—i binary má»›i pháº£i copy láº¡i.
3. **Chá»‰ 1 ELF load region** â€” `__elf_load_start` â†’ `__elf_load_end` = 12 KiB. KhÃ´ng cÃ³ cÆ¡ cháº¿ load binary thá»© 2 vÃ o task khÃ¡c.
4. **User binary linked at fixed address** `0x4010_0000` â€” má»—i binary khÃ¡c nhau cáº§n linker.ld riÃªng vá»›i address khÃ¡c, hoáº·c cáº§n position-independent code.
5. **KhÃ´ng cÃ³ SYS_EXIT** â€” task chá»‰ cÃ³ thá»ƒ: (a) loop forever, (b) fault â†’ auto-restart 100 ticks. KhÃ´ng graceful termination.
6. **IPC chÆ°a formal-verified** â€” SenderQueue cÃ³ thá»ƒ overflow (push returns false nhÆ°ng caller ignores?), cleanup_task() chÆ°a chá»©ng minh completeness.
7. **`include_bytes!` cá»©ng** â€” kernel pháº£i recompile má»—i khi thay Ä‘á»•i user binary. KhÃ´ng flexible.
8. **Cache maintenance inline** trong kernel_main â€” khÃ´ng reusable, hardcoded cho 1 region.
9. **Task 7 dual-role** â€” vá»«a lÃ  IDLE_TASK_ID vá»«a lÃ  ELF demo. Náº¿u multi-ELF thÃ¬ idle nÃªn tÃ¡ch riÃªng.
10. **Kani chÆ°a verify scheduler vá»›i Exited state** â€” náº¿u thÃªm TaskState::Exited, cáº§n update Kani proof `schedule_idle_guarantee`.

---

## CÃ¢u há»i tháº£o luáº­n

### Q1: Multi-ELF Architecture â€” Per-task fixed region hay Shared pool?

Plan Ä‘á» xuáº¥t 6 regions Ã— 16 KiB cá»‘ Ä‘á»‹nh (task 2 â†’ `0x4010_0000`, task 3 â†’ `0x4010_4000`...). NhÆ°ng:

- **(A) Per-task fixed region** (plan hiá»‡n táº¡i): Má»—i task cÃ³ vÃ¹ng nhá»› riÃªng, Ä‘á»‹a chá»‰ cá»‘ Ä‘á»‹nh. User binary cáº§n linker.ld riÃªng cho má»—i slot.
  - âœ… ÄÆ¡n giáº£n, deterministic, dá»… debug
  - âŒ Má»—i binary pháº£i link táº¡i Ä‘Ãºng address â†’ N linker scripts, hoáº·c build script phá»©c táº¡p
  - âŒ Wasted memory náº¿u chá»‰ load 3/6 slots

- **(B) Shared pool + relative loading**: 1 pool lá»›n, allocate theo thá»© tá»± load. User binary link táº¡i offset 0, kernel tÃ­nh load address runtime.
  - âœ… Flexible, 1 linker script cho táº¥t cáº£
  - âŒ Cáº§n position-independent code hoáº·c runtime relocation â€” phá»©c táº¡p hÆ¡n nhiá»u cho `#![no_std]`
  - âŒ Non-deterministic memory layout â†’ khÃ³ verify

- **(C) Hybrid**: Per-task fixed region nhÆ°ng dÃ¹ng build script / macro Ä‘á»ƒ auto-generate linker.ld tá»« template, giáº£m manual work.

CÃ¢n nháº¯c: complexity, W^X enforcement, per-task isolation, build system, tÆ°Æ¡ng lai ASLR.

### Q2: `libsyscall` â€” Standalone crate hay Workspace member?

Plan Ä‘á» xuáº¥t `user/libsyscall/` lÃ  standalone crate. NhÆ°ng:

- **(A) Standalone crate** (plan): `path = "../libsyscall"` dependency. Má»—i user crate depends on it.
  - âœ… Clean separation kernel/user
  - âŒ KhÃ´ng tham gia workspace build â€” pháº£i build riÃªng
  - âŒ Duplicate target spec (`aarch64-user.json`) á»Ÿ má»—i crate

- **(B) Workspace member**: ThÃªm `user/libsyscall` vÃ o Cargo workspace. User crates cÅ©ng lÃ  workspace members.
  - âœ… `cargo build --workspace` builds all
  - âŒ Kernel workspace (aarch64-aegis target) â‰  user workspace (aarch64-user target) â€” conflict target

- **(C) Inline module**: KhÃ´ng táº¡o crate riÃªng, chá»‰ táº¡o `user/libsyscall.rs` rá»“i `include!()` vÃ o má»—i user binary.
  - âœ… Zero dependency overhead
  - âŒ include!() pattern kÃ©m Rust idiom, khÃ³ test

CÃ¢n nháº¯c: build system complexity, custom target handling, maintainability, future growth.

### Q3: Task 7 â€” TÃ¡ch IDLE khá»i ELF demo hay giá»¯ dual-role?

Hiá»‡n task 7 = IDLE_TASK_ID = ELF demo. Plan O1 load ELF vÃ o tasks 2â€“7. NhÆ°ng idle task **PHáº¢I** luÃ´n á»Ÿ tráº¡ng thÃ¡i Ready (scheduler fallback). Náº¿u task 7 cháº¡y ELF code phá»©c táº¡p:

- **(A) Giá»¯ nguyÃªn**: task 7 = idle + ELF demo. ELF chá»‰ in vÃ i byte rá»“i yield forever â†’ functionally idle.
  - âœ… KhÃ´ng thay Ä‘á»•i architecture
  - âŒ ELF demo láº«n vá»›i idle semantics. Náº¿u ELF crash â†’ idle task faulted â†’ scheduler cÃ³ thá»ƒ khÃ´ng tÃ¬m Ä‘Æ°á»£c fallback!

- **(B) TÃ¡ch**: task 7 = idle thuáº§n (wfi loop, khÃ´ng load ELF). ELF demo â†’ task 2â€“6 slot.
  - âœ… IDLE_TASK_ID luÃ´n safe, scheduler guarantee intact
  - âŒ Idle task chá»‰ cáº§n `wfi` loop â€” khÃ´ng cáº§n ELF binary (kernel-internal function)
  - Cáº§n update Kani proof `schedule_idle_guarantee` náº¿u idle task thay Ä‘á»•i

- **(C) Double-idle**: task 7 = primary idle (wfi), task 6 = backup idle. IDLE chá»‰ schedule khi má»i task blocked.
  - âœ… Redundancy
  - âŒ Phá»©c táº¡p, overkill cho hiá»‡n táº¡i

CÃ¢n nháº¯c: scheduler safety guarantee, Kani proof impact, IDLE semantics, task slot utilization.

### Q4: SYS_EXIT scope â€” Chá»‰ self-exit hay thÃªm SYS_KILL (exit task khÃ¡c)?

Plan Ä‘á» xuáº¥t SYS_EXIT (#13) cho self-exit. NhÆ°ng:

- **(A) Chá»‰ SYS_EXIT** (plan): Task tá»± káº¿t thÃºc. KhÃ´ng ai cÃ³ quyá»n kill task khÃ¡c.
  - âœ… Minimal, an toÃ n â€” khÃ´ng ai bá»‹ kill báº¥t ngá»
  - âŒ Task bá»‹ treo (infinite loop nhÆ°ng heartbeat ok) â†’ khÃ´ng cÃ¡ch nÃ o dá»«ng ngoáº¡i trá»« fault

- **(B) SYS_EXIT + SYS_KILL**: ThÃªm syscall #14 cho supervisor task kill task khÃ¡c (vá»›i capability).
  - âœ… System management: supervisor cÃ³ thá»ƒ restart stuck tasks
  - âŒ Phá»©c táº¡p hÆ¡n: capability CAP_KILL, race conditions, cleanup timing
  - âŒ Safety concern: kill chÆ°a xong cleanup cÃ³ thá»ƒ corrupt state

- **(C) SYS_EXIT only, SYS_KILL defer Phase P**: Phase O chá»‰ self-exit. Náº¿u cáº§n kill â†’ dÃ¹ng watchdog (tá»± nhiÃªn fault).

CÃ¢n nháº¯c: safety-critical system needs, supervisor pattern, DO-178C Â§5.6, risk of deadlocked tasks.

### Q5: Kani IPC proofs â€” 3 proofs Ä‘á»§ hay cáº§n má»Ÿ rá»™ng scope?

Plan Ä‘á» xuáº¥t 3 Kani proofs cho IPC: SenderQueue overflow, message integrity, cleanup completeness. NhÆ°ng:

- CÃ³ nÃªn thÃªm **deadlock-freedom proof**? (Chá»©ng minh: khÃ´ng ká»‹ch báº£n nÃ o táº¥t cáº£ tasks Ä‘á»u Blocked vÄ©nh viá»…n)
  - Phá»©c táº¡p: cáº§n model cáº£ scheduler + IPC tÆ°Æ¡ng tÃ¡c
  - Kani bounded model checking cÃ³ thá»ƒ timeout vá»›i 8 tasks Ã— 4 endpoints Ã— 4 waiters

- CÃ³ nÃªn thÃªm **priority inversion proof** cho IPC? (Chá»©ng minh: priority inheritance hoáº¡t Ä‘á»™ng Ä‘Ãºng)
  - `sched.rs` cÃ³ `priority` vÃ  `base_priority` â€” chá»‰ 1-level boost hiá»‡n táº¡i

- **NÃªn update Kani proof `schedule_idle_guarantee` cho TaskState::Exited** â€” thÃªm variant má»›i cáº§n cover.

- ROI: 3 proofs má»›i (6â†’9 tá»•ng) vs 5+ proofs (6â†’11+) â€” diminishing returns?

CÃ¢n nháº¯c: Kani performance limits, CBMC state explosion, DO-333 FM.A-7 coverage depth, time budget.

### Q6: User binary build system â€” Manual per-crate hay automated build script?

Hiá»‡n `user/hello` build riÃªng báº±ng `cargo build --release -Zjson-target-spec`. Plan thÃªm 2+ crates. NhÆ°ng:

- **(A) Manual per-crate**: Má»—i user crate build riÃªng, kernel `include_bytes!` Ä‘Æ°á»ng dáº«n tÄ©nh.
  - âœ… ÄÆ¡n giáº£n, explicit
  - âŒ 6 crates = 6 build commands trÆ°á»›c khi build kernel. QuÃªn 1 cÃ¡i â†’ stale binary

- **(B) Cargo build script** (`build.rs`): Kernel `build.rs` tá»± build táº¥t cáº£ user crates trÆ°á»›c, output paths qua `cargo:rustc-env`.
  - âœ… Single `cargo build` builds everything
  - âŒ build.rs phá»©c táº¡p, cross-compilation tricky (kernel target â‰  user target)

- **(C) Makefile/Script wrapper**: `scripts/build_all.sh` build user crates rá»“i kernel.
  - âœ… Explicit, dá»… debug
  - âŒ NgoÃ i Cargo ecosystem, CI cáº§n update

CÃ¢n nháº¯c: developer experience, CI integration, reproducibility, custom target handling.

---

## RÃ ng buá»™c Ä‘Ã£ biáº¿t

1. **No heap** â€” `include_bytes!` + static linker sections, khÃ´ng dynamic allocation
2. **No FP/SIMD** â€” user binaries cÅ©ng khÃ´ng Ä‘Æ°á»£c dÃ¹ng float
3. **TrapFrame = 288 bytes** â€” ABI-locked, khÃ´ng Ä‘á»•i
4. **W^X enforced** â€” má»—i ELF region pháº£i cÃ³ page attributes Ä‘Ãºng
5. **231 tests + 30 checkpoints = regression gate**
6. **Syscall ABI 0â€“12 khÃ´ng Ä‘á»•i** â€” SYS_EXIT additive (#13)
7. **RAM 128 MiB** â€” 96 KiB ELF regions = 0.07% RAM
8. **Kani cháº¡y trÃªn host (x86_64)** â€” IPC proofs verify pure Rust logic only
9. **Single-core** â€” Cortex-A53, no SMP
10. **User binaries = custom `aarch64-user` target** â€” `#![no_std]`, no FP, strict-align
11. **Phase N consensus**: Scale strategy = Option C (parameterize â†’ validate â†’ flip), experience-first wrapping order, hybrid TaskMetadata

## TiÃªu chÃ­ Ä‘Ã¡nh giÃ¡ thÃ nh cÃ´ng

1. **Functional**: â‰¥3 ELF user tasks (hello + sensor + logger) cháº¡y trÃªn QEMU, IPC sensorâ†’logger hoáº¡t Ä‘á»™ng
2. **Lifecycle**: Ãt nháº¥t 1 task gá»i `SYS_EXIT` thÃ nh cÃ´ng, cleanup verified qua test
3. **Ecosystem**: `libsyscall` crate dÃ¹ng Ä‘Æ°á»£c cho táº¥t cáº£ user binaries, zero duplicate syscall code
4. **Verification**: â‰¥9 Kani proofs pass (6 cÅ© + 3 IPC má»›i), CI green
5. **Regression**: Coverage â‰¥ 98%, 250+ tests pass, 34 QEMU checkpoints pass
6. **Standards**: DO-333 FM.A-7 coverage má»Ÿ rá»™ng (IPC), DO-178C Â§5.5 single source (libsyscall), Â§5.6 graceful shutdown (SYS_EXIT)
7. **Build**: Táº¥t cáº£ user binaries build reproducible, Ä‘Æ°á»ng dáº«n rÃµ rÃ ng
